#!/usr/bin/env python3
import os
import sys
import getopt
import subprocess
from time import sleep
import socket
import re
import signal
import datetime
import asyncio
import uvloop

VERSION = "0.1"
PROGRAM = os.path.basename(__file__)
USAGE = f"""\
{PROGRAM} version {VERSION}.
Display text or graphic to an attached LCD.
Syntax: {PROGRAM} [OPTION] [TEXT]
Common options:
-h           Display this help and exit.
-a           Use asyncio library instead of select(), which is default.
-u           Use uvloop library. Do not use with -a option.
-L host:port Listen on "host:port" for client connections (the daemon mode).
Device options:
-t           LCD type (required). See supported types below.
-i           Initialize/reset LCD (effectively clear the screen).
-x           Clear the screen.
-r           Restore/cleanup GPIO settings (default is not) upon termination..
-B           Turn backlight on.
-b           Turn backlight off.
-d opt       Run a demo name "opt" (default "all") and ignore all other options.
-g           Use graphic mode (if supported).
-z freq      Set LCD communication speed in Hz (if supported) or "-" to revert
             to default value (1953000, 1.95Mhz). A 39.9Mhz (39900000Hz)
             frequency was tested working well on a Raspberry Pi Zero W.
-w usec      Set delay in microsecond between writes to LCD (if supported) or
             "-" to revert to default value (72).
-p           Print LCD parameters.
-s           Show LCD server showStat at the last line.
-v n         Verbose/debug level. Debug messages will be sent to stderr.
Text options:
-f font      Use given font named "font" (if supported).
-l line      Set text line before printing (start from 1, default 1).
-c column    Set text column before printing (start from 1, default 1).
Supported LCD types:
- st7920: 128x64 graphic LCD, ST7920 chip, 8 lines 21 characters, 6x8 font.
- hd44780: 16x2 character LCD, HD44780 chip, 2 lines 16 characters, 5x8 font.
- hd44780opi: it is hd44780 written for Orange Pi boards.
Supported fonts:
- st7920: 4x6, 5x6, 6x8 (default).
"""

debug = 0
quit = False
lcd = None
showStat = False

def onExit(*args):
	global quit
	print("SIGINT or SIGNTERM received.")
	quit = True

def debugLog(msg):
	global debug
	if debug:
		now = datetime.datetime.now()
		print(now.strftime('%Y-%m-%d %H:%M:%S'), msg, file = sys.stderr)

def lcdStat(msg):
	if showStat:
		lcd.printText(msg, line = lcd.lines)

def handleClientMsg(msg):
	"""Handle client's message and return a feedback."""
	global quit
	global lcd
	try:
		cmd, args = msg.split(' ', 1)
		debugLog(f"Command = \"{cmd}\", args = \"{args}\".")
	except ValueError:
		cmd = msg
		debugLog(f"Command = \"{cmd}\", no args.")
	# Handle the extracted command.
	feedback = "OK.\n"
	if cmd == "quit":
		# Terminate.
		debugLog("Terminate.")
		# Send SIGNTERM to this process itself.
		os.kill(os.getpid(), signal.SIGTERM)
		quit = True
	if cmd == "debug":
		debugLog(f"Set debug level {debug}")
		lcd.debug(debug)
	elif cmd == "clear":
		debugLog("Clear screen.")
		lcd.clearScreen()
	elif cmd == "backlight":
		if args == "on":
			debugLog("Turn backlight on.")
			lcd.setBacklight(True)
		elif args == "off":
			debugLog("Turn backlight off.")
			lcd.setBacklight(False)
	elif cmd == "freq":
		if args == "-":
			debugLog("Set frequency to LCD's default.")
			lcd.setFreq(None)
		else:
			debugLog("Set frequency to %sHz" % int(args))
			lcd.setFreq(int(args))
	elif cmd == "delay":
		if args == "-":
			debugLog("Set write delay to LCD's default.")
			lcd.setWriteDelay(None)
		else:
			debugLog("Set write delay to %s usec" % int(args))
			lcd.setWriteDelay(int(args))
	elif cmd == "font":
		if args == "?":
			feedback = "Fonts list: %s.\n" % ", ".join(lcd.getGfxFontNames())
		else:
			if lcd.setGfxFont(args):
				debugLog(f"Font was set to {args}")
			else:
				debugLog(f"Failed to set font to {args}")
				feedback = "ERROR: invalid font %s. Supported fonts: %s.\n" % (
						args, ", ".join(lcd.getGfxFontNames()))
	else:
		m = re.match('^line([0-9]+)', cmd)
		if m:
			line = int(m.groups()[0])
			debugLog(f"Print at line {line} text = \"{args}\".")
			lcd.printText(args, line = line)
	return feedback

class LCDServerProtocol(asyncio.Protocol):
	"""The LCD server class to serve LCD requests in asyncio mode."""
	def connection_made(self, transport):
		addr = transport.get_extra_info('peername')
		debugLog(f'{addr} connected.')
		lcdStat(f">{addr[0]}:{addr[1]} connected")
		self.transport = transport

	def data_received(self, data):
		msg = data.decode().strip()
		addr = self.transport.get_extra_info('peername')
		debugLog(f'Received "{msg}" from {addr}.')
		feedback = handleClientMsg(msg)
		if feedback is not None:
			debugLog(f'Sending "{feedback.strip()}" to {addr}.')
			self.transport.write(msg.encode())
		debugLog(f"Close {addr}.")
		lcdStat(f">{addr[0]}:{addr[1]} closed")
		self.transport.close()

async def asyncShutdown(signal, loop):
	"""Cleanup tasks tied to the service's shutdown."""
	debugLog(f"Received exit signal {signal.name}.")
	# Cancel all running tasks.
	tasks = [t for t in asyncio.all_tasks() if t is not asyncio.current_task()]
	[task.cancel() for task in tasks]
	debugLog(f"Cancelling {len(tasks)} outstanding tasks")
	await asyncio.gather(*tasks, return_exceptions=True)
	debugLog("Stop the service loop.")
	loop.stop()

async def asyncMain(host, port):
	loop = asyncio.get_running_loop()
	# Set up signals handlers first.
	signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
	for s in signals:
		loop.add_signal_handler(
			s, lambda s=s: asyncio.create_task(asyncShutdown(s, loop)))
	# Now create the server loop and run it.
	server = await loop.create_server(lambda: LCDServerProtocol(), host, port)
	async with server:
		try:
			await server.serve_forever()
		except asyncio.CancelledError:
			pass
		finally:
			debugLog("Main service loop closed.")
			lcd.clearScreen()
			lcdStat(">LCDSRV stopped.")
			lcd.setBacklight(False)

def main():
	global debug
	global quit
	global lcd
	global showStat
	# Default settings.
	useAsyncio = False
	useUVLoop = False
	lcdType = None
	init = False
	backlight = None
	gfx = None
	clear = False
	demo = None
	font = None
	softClock = False
	printParams = False
	line = 1
	col = 1
	cleanup = False
	host = None
	port = None
	freq = None
	writeDelay = None

	# Process command line arguments.
	if len(sys.argv) == 1:
		print(USAGE)
		sys.exit(0)
	# Handle commandline arguments.
	try:
		opts, args = getopt.getopt(sys.argv[1:], 'abBc:d:f:ghil:L:prst:xz:w:uv:')
	except getopt.error as err:
		print(f'ERROR: {str(err)}. Use "-h" for usage.', file = sys.stderr)
		sys.exit(1)
	for o, v in opts:
		if o == '-h':
			print(USAGE)
			sys.exit(0)
		elif o == '-a':
			useAsyncio = True
		elif o == '-g':
			gfx = True
		elif o == '-b':
			backlight = False
		elif o == '-B':
			backlight = True
		elif o == '-c':
			col = int(v)
		elif o == '-d':
			demo = v
		elif o == '-f':
			font = v
		elif o == '-i':
			init = True
		elif o == '-l':
			line = int(v)
		elif o == '-L':
			host, port = v.split(':')
			port = int(port)
		elif o == '-p':
			printParams = True
		elif o == '-r':
			cleanup = True
		elif o == '-s':
			showStat = True
		elif o == '-t':
			lcdType = v.lower()
		elif o == '-x':
			clear = True
		elif o == '-z':
			freq = v
		elif o == '-u':
			useUVLoop = True
		elif o == '-v':
			debug = int(v)
		elif o == '-w':
			writeDelay = v
		else:
			print('ERROR: Unknown option. Use "-h" for usage.', file = sys.stderr);
			sys.exit(2)

	text = ' '.join(args)

	if lcdType is None:
		print('ERROR: Missing LCD type.', file = sys.stderr)
		sys.exit(2)
	elif lcdType == "st7920":
		subprocess.run(["gpio", "-g", "mode", "8", "alt0"])
		subprocess.run(["gpio", "-g", "mode", "10", "alt0"])
		subprocess.run(["gpio", "-g", "mode", "11", "alt0"])
		from st7920 import ST7920HSPI
		lcd = ST7920HSPI()
	elif lcdType == "hd44780":
		from hd44780 import HD44780
		lcd = HD44780()
	elif lcdType == "hd44780opi":
		from hd44780opi import HD44780OPiH616
		lcd = HD44780OPiH616()
	else:
		print('ERROR: unsupported LCD.', file = sys.stderr)
		sys.exit(3)

	if lcd is None:
		print('ERROR: Unable to initialize an LCD.', file = sys.stderr)
		sys.exit(4)

	if debug > 0:
		lcd.setDebug(debug)
	if printParams:
		lcd.printParams()
	if freq is not None:
		lcd.setFreq(None if freq == "-" else int(freq))
	if writeDelay is not None:
		lcd.setWriteDelay(None if writeDelay == "-" else int(writeDelay))
	if init:
		lcd.init()
	if backlight is not None:
		lcd.setBacklight(backlight)
	if demo:
		lcd.demo(option = demo)
		sys.exit(0)
	if gfx:
		lcd.setGfxMode()
	else:
		lcd.setTextMode()
	if font is not None:
		lcd.setGfxFont(font)
	if clear:
		lcd.clearScreen()
	if len(text):
		lcd.printText(text, line = line, col = col)
	if cleanup:
		# TODO: handle this.
		pass
 
	if host is not None:
		# Daemon mode.
		print("Activating daemon mode on %s:%s" % (host, port))
		lcd.clearScreen()
		lcd.setBacklight(True)
		lcdStat(">LCDSRV started.")
		if useAsyncio:
			print("Use asyncio.") 
			asyncio.run(asyncMain(host, port))
		elif useUVLoop:
			print("Use uvloop.") 
			uvloop.install()
			asyncio.run(asyncMain(host, port))
		else:
			# Use select().
			print("Use select.") 
			signal.signal(signal.SIGINT, onExit)
			signal.signal(signal.SIGTERM, onExit)
			with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
				s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
				s.bind((host, port))
				s.listen()
				while not quit:
					lcdStat(">Listening...")
					conn, addr = s.accept()
					debugLog(f'{addr} connected.')
					lcdStat(f">{addr[0]}:{addr[1]} connected")
					with conn:
						while True:
							data = conn.recv(1024)
							if not data:
								break
							msg = data.decode().strip()
							debugLog(f'Received "{msg}" from {addr}.')
							feedback = handleClientMsg(msg)
							if feedback is not None:
								try:
									debugLog(f'Sending "{feedback.strip()}" to {addr}')
									conn.sendall(feedback.encode())
									# Only handle 1 command a time, so shutdown now.
									conn.shutdown(socket.SHUT_RDWR)
								except OSError:
									# Ignore connection error, since the client might have problem
									# and close the connection prematurely.
									pass
				# Quit?
				s.shutdown(socket.SHUT_RDWR)
				s.close()
				lcd.clearScreen()
				lcdStat(">LCDSRV stopped.")
				lcd.setBacklight(False)

if __name__ == '__main__':
	main()

