#!/usr/bin/python3
import time
import os
import sys
import getopt
import board
import digitalio
import adafruit_character_lcd.character_lcd as characterlcd
import asyncio
import signal

VERSION = "0.3"
PROGRAM = os.path.basename(__file__)
USAGE = f"""\
{PROGRAM} version {VERSION}.
Display text onto LCD screen.
Syntax: {PROGRAM} [OPTION] [LINE1] [LINE2]
OPTION:
-?      Display this help and exit.
-c      Clear the LCD.
-1 path File to read first line, imply daemon mode.
-2 path File to read second line, imply daemon mode.
-i n    Set scrolling interval (float). Default is 0.5 (second).
-t n    Terminate after n seconds. Otherwise run indefinitely.
-v      Run verbose.
LINE1   A text to display in line 1. This override -1 and -2 options.
LINE2   A text to display in line 2. This override -1 and -2 options.

In daemon mode, this program keep reading file(s) as specified in -1 and -2 
options to get new textx and update the display accordingly. Also in this mode,
if a text line is longer than the display, it will be scroll back and forth
indefinitely or until time out (as specified by -t option).  

Daemon can be used only with -1 and/or -2 option(s).  If -1 and -2 option are
not used, then this program will just display TEXT and then terminate.
"""

# Modify this if you have a different sized character LCD
lcd_columns = 16
lcd_rows = 2

# compatible with all versions of RPI as of Jan. 2019
# v1 - v3B+
lcd_rs = digitalio.DigitalInOut(board.D25)
lcd_en = digitalio.DigitalInOut(board.D24)
lcd_d4 = digitalio.DigitalInOut(board.D23)
lcd_d5 = digitalio.DigitalInOut(board.D17)
lcd_d6 = digitalio.DigitalInOut(board.D18)
lcd_d7 = digitalio.DigitalInOut(board.D22)

def pad16(s):
	""" Padd input string with spaces to make its length 16"""
	if s is not None and len(s) < 16:
		for i in range(16 - len(s)):
			s += " "
	return s

def rotate_left(s):
	""" Rotate the given string 1 character to the left, pads with 4 spaces"""
	l = list(s)
	w = len(l)
	# Store the last character.
	c = l[0]
	# Now shift the string to the left.
	for n in range(w):
		if n == (w - 1):
			l[n] = c
		else:
			l[n] = l[n + 1]
	return "".join(l)

def rotate_right(s):
	""" Rotate the given string 1 character to the right, pads with 4 spaces"""
	l = list(s)
	w = len(l)
	# Store the last character.
	c = l[w - 1]
	# Now shift the string to the right.
	for n in reversed(range(w)):
		if n == 0:
			l[0] = c
		else:
			l[n] = l[n - 1]
	return "".join(l)

async def timer(timeout):
	if g_verbose: print(f"timer: waiting for {timeout} seconds...")
	await asyncio.sleep(timeout)
	if g_verbose: print("timer: timed out. Cancelling tasks...")
	for task in asyncio.all_tasks():
		task.cancel()
	print("timer: all done.")

def sig_handler():
	if g_verbose: print("sig_handler: cancelling tasks...")
	for task in asyncio.all_tasks():
		task.cancel()
	if g_verbose: print("sig_handler: all done.")

async def display(lcd, interval):
	""" Display g_lines on LCD. Texts will be get from a global array """
	global g_lines
	lines = [None, None]
	buf = [None, None]
	directions = [None, None] # None = no scroll, 0 = left, 1 = right.
	steps = [0, 0] # Scroll steps.
	displays = [None, None]
	if g_verbose: print("display: started.")
	while True:
		try:
			for i in range(2):
				check = False
				display = False
				if directions[i] is None:
					# No scrolling. Mark to check for content update.
					check = True
				elif steps[i] == (len(lines[i]) - 16):
					# Done scrolling left or right. Switch direction, also
					# allow checking for update.
					if g_verbose: print(f"display: line {i + 1} switching direction.")
					directions[i] = 0 if directions[i] == 1 else 1
					steps[i] = 0
					check = True
				else:
					# Still scrolling...
					if directions[i] == 0:
						# Scrolling left.
						buf[i] = rotate_left(buf[i])
						if g_verbose: print(f"display: line {i + 1} switch to the left.")
					else:
						# Scrolling right.
						buf[i] = rotate_right(buf[i])
						if g_verbose: print(f"display: line {i + 1} switch to the right.")
					steps[i] += 1
					# Mark for display.
					display = True
				if check and (lines[i] != g_lines[i]):
					# New content.
					lines[i] = g_lines[i]
					if g_verbose: print(f"display: line {i + 1} has new content: \"{lines[i]}\".")
					buf[i] = lines[i]
					# Mark for display.
					display = True
					if len(lines[i]) > 16:
						# Line longer than display, need scrolling.
						directions[i] = 0
						steps[i] = 0
					else:
						# Line is within display, no need for scrolling.
						directions[i] = None
						# But need to add spaces to make it 16 in length.
						buf[i] = pad16(buf[i])
				if display:
					if g_verbose: print(f"display: line {i + 1} display as \"{buf[i][0:16]}\".")
					lcd.cursor_position(0, i)
					lcd.message = buf[i][0:16]
			# After each cycle, wait a bit.
			await asyncio.sleep(interval)
		except asyncio.CancelledError:
			if g_verbose: print("display: got cancelled.")
			break
	if g_verbose: print("display: all done.")

async def read_file(path1, path2):
	""" Read at most first 2 g_lines from given file into a global array."""
	if g_verbose: print("read_file: started.")
	paths = (path1, path2)
	while True:
		try:
			for i in range(2):
				if paths[i] is None:
					break
				if g_verbose: print(f"read_file: reading from {paths[i]}...")
				s = None
				try:
					with open(paths[i], "r") as f:
						s = f.readline().strip()
				except OSError:
					if g_verbose: print(f"read_file: error reading from {paths[i]}")
				if s is None:
					s = ""
				if g_lines[i] != s:
					g_lines[i] = s
					if g_verbose: print(f'read_file: line {i + 1} changed to "{s}".')
			# Wait 1 second before trying to read file again.
			await asyncio.sleep(1)
		except asyncio.CancelledError:
			if g_verbose: print("read_file: got cancelled.")
			break
	if g_verbose: print("read_file: all done.")

g_verbose = False
g_lines = [None, None]

def main():
	global g_verbose
	global g_lines
	# Default settings.
	clear = False
	interval = 0.5
	path1 = None
	path2 = None
	timeout = None
	line1 = None
	line2 = None
	if len(sys.argv) < 2:
		print(USAGE)
		sys.exit(0)
	# Handle commandline arguments.
	try:
		opts, args = getopt.getopt(sys.argv[1:], '?1:2:ci:t:v')
	except getopt.error as err:
		print(f'ERROR: {str(err)}. Use "-?" for usage.', file = sys.stderr)
		sys.exit(1)
	for o, v in opts:
		if o == '-?':
			print(USAGE)
			sys.exit(0)
		elif o == '-c':
			clear = True
		elif o == '-1':
			path1 = v
		elif o == '-2':
			path2 = v
		elif o == '-i':
			interval = float(v)
		elif o == '-t':
			timeout = int(v)
		elif o == '-v':
			g_verbose = True
		else:
			print(f'ERROR: Unrecognized option. Use "-?" for usage.',
				file = sys.stderr)
			sys.exit(2)
	if len(args) > 0:
		line1 = args[0]
		if len(args) > 1:
			line2 = args[1]
	if g_verbose: print("main: started.", file=sys.stderr)
	if all((path1 is None, path2 is None, line1 is None, clear is None)):
		print(f'ERROR: Missing input.', file = sys.stderr)
		sys.exit(3)
	# Initialise the lcd class, this also clear the display.
	lcd = characterlcd.Character_LCD_Mono(lcd_rs, lcd_en, lcd_d4, lcd_d5,
		lcd_d6, lcd_d7, lcd_columns, lcd_rows)
	if all((path1 is None, path2 is None, line1 is None)):
		# No input files and text? Then just quit.
		sys.exit(0)
	if line1 is not None:
		if g_verbose: print(f"main: display line 1 = \"{line1}\".",
			file=sys.stderr)
		lcd.cursor_position(0, 0)
		lcd.message = line1
		if line2 is not None:
			if g_verbose: print(f"main: display line 2 = \"{line2}\".",
				file=sys.stderr)
			lcd.cursor_position(0, 1)
			lcd.message = line2
	else:
		# Start running in daemon mode.
		if g_verbose: print("main: activate daemon mode.", file=sys.stderr)
		if timeout is not None:
			# Include a timer of timeout is set.
			tasks = asyncio.gather(timer(timeout),
				read_file(path1, path2),
				display(lcd, interval))
		else:
			tasks = asyncio.gather(read_file(path1, path2),
				display(lcd, interval))
		loop = asyncio.get_event_loop()
		for sig in (signal.SIGINT, signal.SIGTERM):
			loop.add_signal_handler(sig, sig_handler)
		try:
			loop.run_until_complete(tasks)
		except asyncio.CancelledError:
			pass
		for sig in (signal.SIGINT, signal.SIGTERM):
			loop.remove_signal_handler(sig)
	if g_verbose: print("main: all done.", file=sys.stderr)

# Main entry.
if __name__ == '__main__':
	main()
